---
output: github_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
 collapse = TRUE,
 comment = "#>",
 fig.path = "man/figures/README-",
 out.width = "100%"
)
```

# gdalblock
 
<!-- badges: start -->
<!-- badges: end -->

gdalblock provides block-based access to GDAL raster datasets using S7. It wraps `gdalraster::GDALRaster` and exposes the native tiling (block) structure of raster files, making it easy to read and work with data one block at a time.

## Installation
 
You can install gdalblock from GitHub with:

```r
# install.packages("pak")
pak::pak("hypertidy/gdalblock")
```


Please note that a lot of the S7 implementation is a bit garbled and will change. 

## Why blocks?
 
Raster files are stored internally as tiles (blocks). Cloud-optimized GeoTIFFs (COGs) and many other formats use this structure for efficient partial reads. gdalblock exposes this structure directly so you can:

- Read exactly one block of data at a time
- Know the dimensions and spatial extent of each block
- Process large rasters block-by-block without loading everything into memory
- Work with remote datasets (via `/vsicurl/`) efficiently

GDAL 3.13 has a new vrt:// connection syntax that can read blocks directly with
a concise syntax `vrt://myfile.tif?block=0,0`. The design here of the `read_block()`
matches that syntax exactly and provides the same functionality but with a richer context of much more information. 

## Basic usage

```{r example-basic}
library(gdalblock)

# Open a remote dataset - GEBCO 2024 global bathymetry
dsn <- "/vsicurl/https://projects.pawsey.org.au/idea-gebco-tif/GEBCO_2024.tif"
b <- block(dsn)

# Print shows key properties including block structure
b
```

## Properties

Access dataset properties using `@`:

```{r example-properties}
# Dataset description (file path or URL)
b@dsn

# Dimensions: columns, rows, bands
b@dimension

# Resolution
b@res

# Bounding box: xmin, ymin, xmax, ymax
b@bbox

# Number of bands
b@nbands

# Data type per band
b@datatype

# Block size (standard tile dimensions)
b@blocksize

# Number of blocks in x and y
b@nblocks

# Full block structure including edge block sizes
b@blocks
```

The `blocks` property shows that edge blocks (rightmost column, bottom row) may be smaller than the standard block size.

## Reading blocks

Blocks are indexed from 0 (following GDAL convention). Use `read_block(x, i, j)` where `i` is the column index and `j` is the row index:
 
```{r example-read}
# Read the top-left block
m <- read_block(b, 0, 0)
dim(m)
class(m)

# Read an edge block (bottom-right corner)
m_edge <- read_block(b, b@nblocks[1] - 1, b@nblocks[2] - 1)
dim(m_edge)  # Smaller dimensions due to edge effects
```

## Block metadata

Get information about a specific block without reading the data:

```{r example-metadata}
# Block dimensions (may differ for edge blocks)
block_dim(b, 0, 0)
block_dim(b, 168, 84)  # Edge block

# Block bounding box in dataset coordinates
block_bbox(b, 0, 0)

# Pixel/line offsets (for use with GDAL read operations)
block_index(b, 0, 0)
```

## Example: Plotting a region

Here's how to find a block covering a specific location and plot it. We'll map Tasmania:

```{r example-tasmania, fig.width=8, fig.height=7}
library(gdalblock)

dsn <- "/vsicurl/https://projects.pawsey.org.au/idea-gebco-tif/GEBCO_2024.tif"
b <- block(dsn)

# Tasmania is roughly at 147째E, 42째S
# Calculate which block contains this location
target_lon <- 147
target_lat <- -42

# Block indices (0-based)
i <- floor((target_lon - b@bbox[1]) / (b@blocksize[1] * b@res[1]))
j <- floor((b@bbox[4] - target_lat) / (b@blocksize[2] * b@res[2]))
cat("Block indices:", i, j, "\n")

# Read the block
m <- read_block(b, i, j)

# Get block extent for plotting
bb <- block_bbox(b, i, j)
xlim <- c(bb[1], bb[3])
ylim <- c(bb[2], bb[4])

# Scale data to 0-1 for RGB display
m_scaled <- (m - min(m)) / (max(m) - min(m))
rgb_array <- array(m_scaled, dim = c(dim(m), 3))

# Plot
par(mar = c(4, 4, 2, 1))
plot(NULL, xlim = xlim, ylim = ylim, asp = 1 / cos(mean(ylim) * pi / 180),
     xlab = "Longitude", ylab = "Latitude", main = "Eastern Tasmania (GEBCO 2024)")

# rasterImage uses same orientation as read_block - no flip needed
rasterImage(rgb_array, xlim[1], ylim[1], xlim[2], ylim[2])

# Add coastline contour at 0m (sea level)
# contour() needs ascending y values, so we flip the matrix
x_seq <- seq(xlim[1], xlim[2], length.out = ncol(m))
y_seq <- seq(ylim[2], ylim[1], length.out = nrow(m))  # Descending (image order)
y_seq_asc <- rev(y_seq)

contour(x_seq, y_seq_asc, t(m[nrow(m):1, ]), levels = 0, 
        add = TRUE, col = "red", lwd = 2, drawlabels = FALSE)
```

## Try another location: Auckland

```{r example-auckland, fig.width=8, fig.height=7}
# Auckland is roughly at 175째E, 37째S
target_lon <- 175
target_lat <- -37

i <- floor((target_lon - b@bbox[1]) / (b@blocksize[1] * b@res[1]))
j <- floor((b@bbox[4] - target_lat) / (b@blocksize[2] * b@res[2]))
cat("Block indices:", i, j, "\n")

m <- read_block(b, i, j)
bb <- block_bbox(b, i, j)
xlim <- c(bb[1], bb[3])
ylim <- c(bb[2], bb[4])

m_scaled <- (m - min(m)) / (max(m) - min(m))
rgb_array <- array(m_scaled, dim = c(dim(m), 3))

par(mar = c(4, 4, 2, 1))
plot(NULL, xlim = xlim, ylim = ylim, asp = 1 / cos(mean(ylim) * pi / 180),
     xlab = "Longitude", ylab = "Latitude", main = "Auckland Region (GEBCO 2024)")

rasterImage(rgb_array, xlim[1], ylim[1], xlim[2], ylim[2])

x_seq <- seq(xlim[1], xlim[2], length.out = ncol(m))
y_seq <- seq(ylim[2], ylim[1], length.out = nrow(m))
y_seq_asc <- rev(y_seq)

contour(x_seq, y_seq_asc, t(m[nrow(m):1, ]), levels = 0, 
        add = TRUE, col = "red", lwd = 2, drawlabels = FALSE)
```


## Block geometry as data structures
 
Block extents are available as `wk::rct` vectors for easy plotting and spatial operations:
```{r example-rct}
# All blocks as wk::rct (with CRS)
rcts <- block_rct(b)
rcts[1:3]

# Subset of blocks
block_rct(b, 0:2, 0:2)

# Plot all blocks (uses wk::wk_plot internally
plot_block(b)
```

For full metadata including pixel offsets, use `block_data()`:
```{r example-data}
# Returns data.frame with i, j, offsets, extents, and geometry
df <- block_data(b, 0:2, 0:2)
df[, c("i", "j", "xoff", "yoff", "xsize", "ysize")]
```

## Finding blocks by region

Query blocks that intersect a bounding box or extent:
```{r example-intersection}
# Define a region of interest (bbox style: xmin, ymin, xmax, ymax)
roi <- c(140, -45, 155, -35)  # Southeast Australia

# Get intersecting blocks as wk::rct
tiles <- blocks_in_bbox(b, roi)
tiles

# Or with full metadata
tiles_df <- blocks_in_bbox(b, roi, data = TRUE)
tiles_df[, c("i", "j", "xmin", "ymin", "xmax", "ymax")]

# Plot the intersection
plot_block_bbox(b, roi, col = "lightblue", border = "gray")
```

The extent-style functions use `c(xmin, xmax, ymin, ymax)` ordering:
```{r example-ext}
# Extent style: xmin, xmax, ymin, ymax
roi_ext <- c(140, 155, -45, -35)
blocks_in_ext(b, roi_ext)
```

## Accessing the underlying GDALRaster object

If you need full access to the gdalraster API, the underlying `GDALRaster` object is available:

```{r example-ds}
# Access the GDALRaster object
b@ds

# Use gdalraster methods directly
b@ds$getDriverShortName()
b@ds$getMetadata(band = 0, domain = "IMAGE_STRUCTURE")
```

## Related packages

- [gdalraster](https://github.com/firelab/gdalraster) - The underlying GDAL bindings
- [terra](https://github.com/rspatial/terra) - Full-featured raster analysis
- [grout](https://github.com/hypertidy/grout) - Tiling logic

gdalblock is intentionally minimal - it focuses on exposing block structure for efficient partial reads, particularly useful for cloud-optimized formats and remote data access.


## Code of Conduct
  
Please note that the gdalblock project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/1/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.
